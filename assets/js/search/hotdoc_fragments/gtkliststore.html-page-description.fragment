fragment_downloaded_cb({"url": "gtkliststore.html#page-description", "fragment": "The GtkListStore object is a list model for use with a GtkTreeView widget. It implements the GtkTreeModel interface and consequentialy can use all of the methods available there. It also implements the GtkTreeSortable interface so it can be sorted by the view. Finally it also implements the tree drag and drop gtk3 GtkTreeView drag and drop interfaces. \nThe GtkListStore can accept most GObject types as a column type though it can t accept all custom types. Internally it will keep a copy of data passed in such as a string or a boxed pointer Columns that accept GObject are handled a little differently. The GtkListStore will keep a reference to the object instead of copying the value. As a result if the object is modified it is up to the application writer to call gtk_tree_model_row_changed to emit the GtkTreeModel row_changed signal. This most commonly affects lists with GdkPixbuf stored. \nAn example for creating a simple list store \nInternally the GtkListStore was implemented with a linked list with a tail pointer prior to GTK As a result it was fast at data insertion and deletion and not fast at random data access. The GtkListStore sets the GTK_TREE_MODEL_ITERS_PERSIST flag which means that GtkTreeIter can be cached while the row exists. Thus if access to a particular row is needed often and your code is expected to run on older versions of GTK it is worth keeping the iter around. \nIt is important to note that only the methods gtk_list_store_insert_with_values and gtk_list_store_insert_with_valuesv are atomic in the sense that the row is being appended to the store and the values filled in in a single operation with regard to GtkTreeModel signaling. In contrast using e.g. gtk_list_store_append and then gtk_list_store_set will first create a row which triggers the row inserted signal on GtkListStore. The row however is still empty and any signal handler connecting to row inserted on this particular store should be prepared for the situation that the row might be empty. This is especially important if you are wrapping the GtkListStore inside a GtkTreeModelFilter and are using a GtkTreeModelFilterVisibleFunc. Using any of the non atomic operations to append rows to the GtkListStore will cause the GtkTreeModelFilterVisibleFunc to be visited with an empty row first the function must be prepared for that. \nThe GtkListStore implementation of the GtkBuildable interface allows to specify the model columns with a element that may contain multiple elements each specifying one model column. The type attribute specifies the data type for the column. \nAdditionally it is possible to specify content for the list store in the UI definition with the element. It can contain multiple elements each specifying to content for one row of the list model. Inside a the elements specify the content for individual cells. \nNote that it is probably more common to define your models in the code and one might consider it a layering violation to specify the content of a list store in a UI definition data not presentation and common wisdom is to separate the two as far as possible. \nAn example of a UI Definition fragment for a list store \n"});