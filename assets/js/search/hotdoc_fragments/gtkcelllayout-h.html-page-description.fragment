fragment_downloaded_cb({"url": "gtkcelllayout-h.html#page-description", "fragment": "GtkCellLayout is an interface to be implemented by all objects which want to provide a GtkTreeViewColumn like API for packing cells setting attributes and data funcs. \nOne of the notable features provided by implementations of GtkCellLayout are attributes. Attributes let you set the properties in flexible ways. They can just be set to constant values like regular properties. But they can also be mapped to a column of the underlying tree model with gtk_cell_layout_set_attributes which means that the value of the attribute can change from cell to cell as they are rendered by the cell renderer. Finally it is possible to specify a function with gtk_cell_layout_set_cell_data_func that is called to determine the value of the attribute for each cell that is rendered. \nImplementations of GtkCellLayout which also implement the GtkBuildable interface GtkCellView GtkIconView GtkComboBox GtkEntryCompletion GtkTreeViewColumn accept GtkCellRenderer objects as elements in UI definitions. They support a custom element for their children which can contain multiple elements. Each element has a name attribute which specifies a property of the cell renderer the content of the element is the attribute value. \nThis is an example of a UI definition fragment specifying attributes \nFurthermore for implementations of GtkCellLayout that use a GtkCellArea to lay out cells all GtkCellLayouts in GTK use a GtkCellArea cell properties cell properties can also be defined in the format by specifying the custom attribute which can contain multiple elements defined in the normal way. \nHere is a UI definition fragment specifying cell properties \nWhen subclassing a widget that implements GtkCellLayout like GtkIconView or GtkComboBox there are some considerations related to the fact that these widgets internally use a GtkCellArea. The cell area is exposed as a construct only property by these widgets. This means that it is possible to e.g. do \nto use a custom cell area with a combo box. But construct properties are only initialized after instance init functions have run which means that using functions which rely on the existence of the cell area in your subclass init function will cause the default cell area to be instantiated. In this case a provided construct property value will be ignored with a warning to alert you to the problem \nIf supporting alternative cell areas with your derived widget is not important then this does not have to concern you. If you want to support alternative cell areas you can do so by moving the problematic calls out of init and into a constructor for your class. \n"});