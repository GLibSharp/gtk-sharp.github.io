fragment_downloaded_cb({"url": "getting_started.html#page-description", "fragment": "GTK is a widget toolkit. Each user interface created by GTK consists of widgets. This is implemented in C using GObject an object oriented framework for C. Widgets are organized in a hierachy. The window widget is the main container. The user interface is then built by adding buttons drop down menus input fields and other widgets to the window. If you are creating complex user interfaces it is recommended to use GtkBuilder and its GTK specific markup description language instead of assembling the interface manually. You can also use a visual user interface editor like Glade. \nGTK is event driven. The toolkit listens for events such as a click on a button and passes the event to your application. \nThis chapter contains some tutorial information to get you started with GTK programming. It assumes that you have GTK its dependencies and a C compiler installed and ready to use. If you need to build GTK itself first refer to the Compiling the GTK libraries section in this reference. \nTo begin our introduction to GTK we ll start with a simple signal based Gtk application. This program will create an empty pixel window. \n\nCreate a new file with the following content named example c. \nYou can compile the program above with GCC using gcc pkg config cflags gtk o example example c pkg config libs gtk \nNote \nFor more information on how to compile a GTK application please refer to the Compiling GTK Applications section in this reference. \nAll GTK applications will of course include gtk gtk.h which declares functions types and macros required by GTK applications. \nWarning \nEven if GTK installs multiple header files only the top level gtk gtk.h header can be directly included by third party code. The compiler will abort with an error if any other header is directly included. \nIn a GTK application the purpose of the main function is to create a GtkApplication object and run it. In this example a GtkApplication pointer named app is called and then initialized using gtk_application_new \nWhen creating a GtkApplication you need to pick an application identifier a name and input to gtk_application_new as parameter. For this example org.gtk.example is used but for choosing an identifier for your application see this guide. Lastly gtk_application_new takes a GApplicationFlags as input for your application if your application would have special needs. \nNext the activate signal is connected to the activate function above the main functions. The activate signal will be sent when your application is launched with g_application_run on the line below. The gtk_application_run also takes as arguments the pointers to the command line arguments counter and string array this allows GTK to parse specific command line arguments that control the behavior of GTK itself. The parsed arguments will be removed from the array leaving the unrecognized ones for your application to parse. \nWithin g_application_run the activate signal is sent and we then proceed into the activate function of the application. Inside the activate function we want to construct our GTK window so that a window is shown when the application is launched. The call to gtk_application_window_new will create a new GtkWindow and store it inside the window pointer. The window will have a frame a title bar and window controls depending on the platform. \nA window title is set using gtk_window_set_title This function takes a GtkWindow pointer and a string as input. As our window pointer is a GtkWidget pointer we need to cast it to GtkWindow But instead of casting window via GtkWindow window can be cast using the macro GTK_WINDOW GTK_WINDOW will check if the pointer is an instance of the GtkWindow class before casting and emit a warning if the check fails. More information about this convention can be found here. \nFinally the window size is set using gtk_window_set_default_size and the window is then shown by GTK via gtk_widget_show_all \nWhen you exit the window by for example pressing the X the g_application_run in the main loop returns with a number which is saved inside an integer named status Afterwards the GtkApplication object is freed from memory with g_object_unref Finally the status integer is returned and the GTK application exits. \nWhile the program is running GTK is receiving events. These are typically input events caused by the user interacting with your program but also things like messages from the window manager or other applications. GTK processes these and as a result signals may be emitted on your widgets. Connecting handlers for these signals is how you normally make your program do something in response to user input. \nThe following example is slightly more complex and tries to showcase some of the capabilities of GTK \nIn the long tradition of programming languages and libraries it is called Hello World. \n\nCreate a new file with the following content named example c. \nYou can compile the program above with GCC using gcc pkg config cflags gtk o example example c pkg config libs gtk \nAs seen above example c builds further upon example c by adding a button to our window with the label Hello World Two new GtkWidget pointers are declared to accomplish this button and button_box. The button_box variable is created to store a GtkButtonBox which is GTK s way of controlling the size and layout of buttons. The GtkButtonBox is created and assigned to gtk_button_box_new which takes a GtkOrientation enum as parameter. The buttons which this box will contain can either be stored horizontally or vertically but this does not matter in this particular case as we are dealing with only one button. After initializing button_box with horizontal orientation the code adds the button_box widget to the window widget using gtk_container_add \nNext the button variable is initialized in similar manner. gtk_button_new_with_label is called which returns a GtkButton to be stored inside button. Afterwards button is added to our button_box. Using g_signal_connect the button is connected to a function in our app called print_hello so that when the button is clicked GTK will call this function. As the print_hello function does not use any data as input NULL is passed to it. print_hello calls g_print with the string Hello World which will print Hello World in a terminal if the GTK application was started from one. \nAfter connecting print_hello another signal is connected to the clicked state of the button using g_signal_connect_swapped This functions is similar to a g_signal_connect with the difference lying in how the callback function is treated. g_signal_connect_swapped allow you to specify what the callback function should take as parameter by letting you pass it as data. In this case the function being called back is gtk_widget_destroy and the window pointer is passed to it. This has the effect that when the button is clicked the whole GTK window is destroyed. In contrast if a normal g_signal_connect were used to connect the clicked signal with gtk_widget_destroy then the button itself would have been destroyed not the window. More information about creating buttons can be found here. \nThe rest of the code in example c is identical to example c. Next section will elaborate further on how to add several GtkWidgets to your GTK application. \nWhen creating an application you ll want to put more than one widget inside a window. When you want to put more than one widget into a window it becomes important to control how each widget is positioned and sized. This is where packing comes in. \nGTK comes with a large variety of layout containers whose purpose it is to control the layout of the child widgets that are added to them. See Layout Containers for an overview. \nThe following example shows how the GtkGrid container lets you arrange several buttons \n\nCreate a new file with the following content named example c. \nYou can compile the program above with GCC using gcc pkg config cflags gtk o example example c pkg config libs gtk \nWhen construcing a more complicated user interface with dozens or hundreds of widgets doing all the setup work in C code is cumbersome and making changes becomes next to impossible. \nThankfully GTK supports the separation of user interface layout from your business logic by using UI descriptions in an XML format that can be parsed by the GtkBuilder class. \nCreate a new file with the following content named example c. \nCreate a new file with the following content named builder.ui. \nYou can compile the program above with GCC using gcc pkg config cflags gtk o example example c pkg config libs gtk \nNote that GtkBuilder can also be used to construct objects that are not widgets such as tree models adjustments etc. That is the reason the method we use here is called gtk_builder_get_object and returns a GObject instead of a GtkWidget \nNormally you would pass a full path to gtk_builder_add_from_file to make the execution of your program independent of the current directory. A common location to install UI descriptions and similar data is usr share appname. \nIt is also possible to embed the UI description in the source code as a string and use gtk_builder_add_from_string to load it. But keeping the UI description in a separate file has several advantages It is then possible to make minor adjustments to the UI without recompiling your program and more importantly graphical UI editors such as glade can load the file and allow you to create and modify your UI by point and click. \nAn application consists of a number of files \nGTK includes application support that is built on top of GApplication. In this tutorial we ll build a simple application by starting from scratch adding more and more pieces over time. Along the way we ll learn about GtkApplication templates resources application menus settings GtkHeaderBar GtkStack GtkSearchBar GtkListBox and more. \nThe full buildable sources for these examples can be found in the examples directory of the GTK source distribution or online in the GTK git repository. You can build each example separately by using make with the Makefile.example file. For more information see the README included in the examples directory. \nWhen using GtkApplication the main function can be very simple. We just call g_application_run and give it an instance of our application class. \nAll the application logic is in the application class which is a subclass of GtkApplication. Our example does not yet have any interesting functionality. All it does is open a window when it is activated without arguments and open the files it is given if it is started with arguments. \nTo handle these two cases we override the activate vfunc which gets called when the application is launched without commandline arguments and the open vfunc which gets called when the application is launched with commandline arguments. \nTo learn more about GApplication entry points consult the GIO documentation. \nAnother important class that is part of the application support in GTK is GtkApplicationWindow. It is typically subclassed as well. Our subclass does not do anything yet so we will just get an empty window. \nAs part of the initial setup of our application we also create an icon and a desktop file. \n\nNote that bindir needs to be replaced with the actual path to the binary before this desktop file can be used. \nHere is what we ve achieved so far \n\nThis does not look very impressive yet but our application is already presenting itself on the session bus it has single instance semantics and it accepts files as commandline arguments. \nIn this step we use a GtkBuilder template to associate a GtkBuilder ui file with our application window class. \nOur simple ui file puts a GtkHeaderBar on top of a GtkStack widget. The header bar contains a GtkStackSwitcher which is a standalone widget to show a row of tabs for the pages of a GtkStack. \nTo make use of this file in our application we revisit our GtkApplicationWindow subclass and call gtk_widget_class_set_template_from_resource from the class init function to set the ui file as template for this class. We also add a call to gtk_widget_init_template in the instance init function to instantiate the template for each instance of our class. \nfull source \nYou may have noticed that we used the _from_resource variant of the function that sets a template. Now we need to use GLib s resource functionality to include the ui file in the binary. This is commonly done by listing all resources in a gresource.xml file such as this \nThis file has to be converted into a C source file that will be compiled and linked into the application together with the other source files. To do so we use the glib compile resources utility \nOur application now looks like this \n\nIn this step we make our application show the content of all the files that it is given on the commandline. \nTo this end we add a private struct to our application window subclass and keep a reference to the GtkStack there. The gtk_widget_class_bind_template_child_private function arranges things so that after instantiating the template the stack member of the private struct will point to the widget of the same name from the template. \nfull source \nNow we revisit the example_app_window_open function that is called for each commandline argument and construct a GtkTextView that we then add as a page to the stack \nfull source \nNote that we did not have to touch the stack switcher at all. It gets all its information from the stack that it belongs to. Here we are passing the label to show for each file as the last argument to the gtk_stack_add_titled function. \nOur application is beginning to take shape \n\nAn application menu is shown by GNOME shell at the top of the screen. It is meant to collect infrequently used actions that affect the whole application. \nJust like the window template we specify our application menu in a ui file and add it as a resource to our binary. \nTo associate the app menu with the application we have to call gtk_application_set_app_menu Since app menus work by activating GActions we also have to add a suitable set of actions to our application. \nBoth of these tasks are best done in the startup vfunc which is guaranteed to be called once for each primary application instance \nfull source \nOur preferences menu item does not do anything yet but the Quit menu item is fully functional. Note that it can also be activated by the usual Ctrl Q shortcut. The shortcut was added with gtk_application_set_accels_for_action \nThe application menu looks like this \n\nA typical application will have a some preferences that should be remembered from one run to the next. Even for our simple example application we may want to change the font that is used for the content. \nWe are going to use GSettings to store our preferences. GSettings requires a schema that describes our settings \nBefore we can make use of this schema in our application we need to compile it into the binary form that GSettings expects. GIO provides macros to do this in autotools based projects. \nNext we need to connect our settings to the widgets that they are supposed to control. One convenient way to do this is to use GSettings bind functionality to bind settings keys to object properties as we do here for the transition setting. \nfull source \nThe code to connect the font setting is a little more involved since there is no simple object property that it corresponds to so we are not going to go into that here. \nAt this point the application will already react if you change one of the settings e.g. using the gsettings commandline tool. Of course we expect the application to provide a preference dialog for these. So lets do that now. Our preference dialog will be a subclass of GtkDialog and we ll use the same techniques that we ve already seen templates private structs settings bindings. \nLets start with the template. \nNext comes the dialog subclass. \nNow we revisit the preferences_activated function in our application class and make it open a new preference dialog. \nfull source \nAfter all this work our application can now show a preference dialog like this \n\nWe continue to flesh out the functionality of our application. For now we add search. GTK supports this with GtkSearchEntry and GtkSearchBar. The search bar is a widget that can slide in from the top to present a search entry. \nWe add a toggle button to the header bar which can be used to slide out the search bar below the header bar. \nImplementing the search needs quite a few code changes that we are not going to completely go over here. The central piece of the search implementation is a signal handler that listens for text changes in the search entry. \nfull source \nWith the search bar our application now looks like this \n\nAs another piece of functionality we are adding a sidebar which demonstrates GtkMenuButton GtkRevealer and GtkListBox. \nThe code to populate the sidebar with buttons for the words found in each file is a little too involved to go into here. But we ll look at the code to add the gears menu. \nAs expected by now the gears menu is specified in a GtkBuilder ui file. \nTo connect the menuitem to the show words setting we use a GAction corresponding to the given GSettings key. \nfull source \nWhat our application looks like now \n\nWidgets and other objects have many useful properties. \nHere we show some ways to use them in new and flexible ways by wrapping them in actions with GPropertyAction or by binding them with GBinding. \nTo set this up we add two labels to the header bar in our window template named lines_label and lines and bind them to struct members in the private struct as we ve seen a couple of times by now. \nWe add a new Lines menu item to the gears menu which triggers the show lines action \nTo make this menu item do something we create a property action for the visible property of the lines label and add it to the actions of the window. The effect of this is that the visibility of the label gets toggled every time the action is activated. \nSince we want both labels to appear and disappear together we bind the visible property of the lines_label widget to the same property of the lines widget. \nfull source \nWe also need a function that counts the lines of the currently active tab and updates the lines label. See the full source if you are interested in the details. \nThis brings our example application to this appearance \n\nOur application already uses a GtkHeaderBar but so far it still gets a normal window titlebar on top of that. This is a bit redundant and we will now tell GTK to use the header bar as replacement for the titlebar. To do so we move it around to be a direct child of the window and set its type to be titlebar. \nA small extra bonus of using a header bar is that we get a fallback application menu for free. Here is how the application now looks if this fallback is used. \n\nIf we set up the window icon for our window the menu button will use that instead of the generic placeholder icon you see here. \nMany widgets like buttons do all their drawing themselves. You just tell them the label you want to see and they figure out what font to use draw the button outline and focus rectangle etc. Sometimes it is necessary to do some custom drawing. In that case a GtkDrawingArea might be the right widget to use. It offers a canvas on which you can draw by connecting to the GtkWidget draw signal. \nThe contents of a widget often need to be partially or fully redrawn e.g. when another window is moved and uncovers part of the widget or when the window containing it is resized. It is also possible to explicitly cause part or all of the widget to be redrawn by calling gtk_widget_queue_draw or its variants. GTK takes care of most of the details by providing a ready to use cairo context to the draw signal handler. \nThe following example shows a draw signal handler. It is a bit more complicated than the previous examples since it also demonstrates input event handling by means of button press and motion notify handlers. \n\nCreate a new file with the following content named example c. \nYou can compile the program above with GCC using gcc pkg config cflags gtk o example example c pkg config libs gtk \n"});