fragment_downloaded_cb({"url": "hotdoc_markdown/gtkwidget.html#gtk_widget_class_bind_template_child_full", "fragment": "gtk_widget_class_bind_template_child_full \nGtk.prototype.bind_template_child_full \nAutomatically assign an object declared in the class template XML to be set to a location on a freshly built instance s private data or alternatively accessible via gtk_widget_get_template_child. \nThe struct can point either into the public instance then you should use G_STRUCT_OFFSET WidgetType member for struct_offset or in the private struct then you should use G_PRIVATE_OFFSET WidgetType member \nAn explicit strong reference will be held automatically for the duration of your instance s life cycle it will be released automatically when dispose runs on your instance and if a struct_offset that is is specified then the automatic location in your instance public or private data will be set to NULL. You can however access an automated child pointer the first time your classes dispose runs or alternatively in destroy \nIf internal_child is specified get_internal_child will be automatically implemented by the GtkWidget class so there is no need to implement it manually. \nThe wrapper macros gtk_widget_class_bind_template_child gtk_widget_class_bind_template_child_internal gtk_widget_class_bind_template_child_private and gtk_widget_class_bind_template_child_internal_private might be more convenient to use. \nNote that this must be called from a composite widget classes class initializer after calling gtk_widget_class_set_template. \nParameters \nA GtkWidgetClass \nThe id of the child defined in the template XML \nWhether the child should be accessible as an internal child when this class is used in GtkBuilder XML \nThe structure offset into the composite widget s instance public or private structure where the automated child pointer should be set or to not assign the pointer. \nSince \nAutomatically assign an object declared in the class template XML to be set to a location on a freshly built instance s private data or alternatively accessible via Gtk.prototype.get_template_child. \nThe struct can point either into the public instance then you should use G_STRUCT_OFFSET WidgetType member for struct_offset or in the private struct then you should use G_PRIVATE_OFFSET WidgetType member \nAn explicit strong reference will be held automatically for the duration of your instance s life cycle it will be released automatically when ObjectClass.dispose runs on your instance and if a struct_offset that is is specified then the automatic location in your instance public or private data will be set to null. You can however access an automated child pointer the first time your classes ObjectClass.dispose runs or alternatively in destroy \nIf internal_child is specified get_internal_child will be automatically implemented by the Gtk.Widget class so there is no need to implement it manually. \nThe wrapper macros gtk_widget_class_bind_template_child not introspectable gtk_widget_class_bind_template_child_internal not introspectable gtk_widget_class_bind_template_child_private not introspectable and gtk_widget_class_bind_template_child_internal_private not introspectable might be more convenient to use. \nNote that this must be called from a composite widget classes class initializer after calling Gtk.prototype.set_template. \nParameters \nA Gtk.WidgetClass \nThe id of the child defined in the template XML \nWhether the child should be accessible as an internal child when this class is used in GtkBuilder XML \nThe structure offset into the composite widget s instance public or private structure where the automated child pointer should be set or to not assign the pointer. \nSince \n"});