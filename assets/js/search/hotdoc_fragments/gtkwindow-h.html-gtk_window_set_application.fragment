fragment_downloaded_cb({"url": "gtkwindow-h.html#gtk_window_set_application", "fragment": "Gtk.prototype.set_application \nGtk.Window.set_application \ngtk_window_set_application \nSets or unsets the Gtk.Application associated with the window. \nThe application will be kept alive for at least as long as it has any windows associated with it see Gio.prototype.hold for a way to keep it alive without windows \nNormally the connection between the application and the window will remain until the window is destroyed but you can explicitly remove it by setting the application to null. \nThis is equivalent to calling Gtk.prototype.remove_window and or Gtk.prototype.add_window on the old new applications as relevant. \nParameters \na Gtk.Window \na Gtk.Application or null to unset \nSince \nSets or unsets the Gtk.Application associated with the window. \nThe application will be kept alive for at least as long as it has any windows associated with it see Gio.Application.hold for a way to keep it alive without windows \nNormally the connection between the application and the window will remain until the window is destroyed but you can explicitly remove it by setting the application to None. \nThis is equivalent to calling Gtk.Application.remove_window and or Gtk.Application.add_window on the old new applications as relevant. \nParameters \na Gtk.Window \na Gtk.Application or None to unset \nSince \nSets or unsets the GtkApplication associated with the window. \nThe application will be kept alive for at least as long as it has any windows associated with it see g_application_hold for a way to keep it alive without windows \nNormally the connection between the application and the window will remain until the window is destroyed but you can explicitly remove it by setting the application to NULL. \nThis is equivalent to calling gtk_application_remove_window and or gtk_application_add_window on the old new applications as relevant. \nParameters \na GtkWindow \na GtkApplication or NULL to unset \nSince \n"});